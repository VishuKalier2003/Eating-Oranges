/* There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:
* Eat one orange...
* If the number of remaining oranges n is divisible by 2 then you can eat n / 2 oranges...
* If the number of remaining oranges n is divisible by 3 then you can eat 2 * (n / 3) oranges...
You can only choose one of the actions per day... Given the integer n, return the minimum number of days to eat n oranges... 
  * Eg 1: oranges = 10         Output = 4
  * Explanation of above case -> {You have 10 oranges. Day 1: Eat 1 orange,  10 - 1 = 9. Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3) Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. Day 4: Eat the last orange  1 - 1  = 0. You need at least 4 days to eat the 10 oranges.}
  * Eg 2: oranges = 6          Output = 3 
*/
import java.util.*;
public class Oranges
{
    public int LeastDaysToEat(int n)
    {
        int days = 0;
        Queue<Integer> queue = new LinkedList<Integer>();
        queue.offer(n);  // Adding the element to the Queue without encountering capacity restrictions...
        Set<Integer> set = new HashSet<Integer>();    // HashSet to keep the unique elements in check...
        while(!queue.isEmpty())
        {
            days++;    // Incrementing the days...
            int size = queue.size();       // Getting size of the Queue...
            for(int i = 0; i < size; i++)
            {
                int current = queue.poll();    // Removing the head of the Queue...
                if(current == 0)      // Base condition if there were no Oranges...
                    return days - 1;
                if(set.contains(current))     // If the Set contains the current number of Oranges...
                    continue;
                else
                    set.add(current);
                System.out.println(set);
                if(current % 3 == 0)     // If Queue is divisible by three...
                    queue.offer(current / 3);
                if(current % 2 == 0)     // If Queue is divisible by two...
                    queue.offer(current / 2);
                queue.offer(current - 1);        // If Queue is divisible by one, this ensures that until there are no Oranges left, the Queue never becomes empty...
            }
        }
        return days;
    }
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        int x;
        System.out.print("Enter the number of Oranges : ");
        x = sc.nextInt();
        Oranges oranges = new Oranges();    // Object creation...
        System.out.println("The Minimum number of Days to eat all Oranges : "+oranges.LeastDaysToEat(x));
        sc.close();
    }
}

// Time Complexity  - O(n) time...
// Space Complexity - O(n) space...

/* DEDUCTIONS :- 
 * 1. Since for every case we have three possible results, we can assume this as a graph problem where each node has three children nodes and all the leaf nodes have the value of one...
 * 2. Since we can Implement Breath-First-Search we use a Queue to traverse all the possible children of the graph and get thee least number of days iteratively...
*/